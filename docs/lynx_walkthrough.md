# vhybZ + Lynx: Walkthrough

## 1. Our Use Case: Dynamic UI & Logic Rendering with Lynx

Our goal is to build a mobile app where users (through LLM code generation) can write, execute, and reconfigure JavaScript code at runtime to dynamically create, update, and render UI components. All without a backend! vhybZ is not just a playground: we want a robust, production-ready “live code editor and runner” for mobile, supporting both UI and business logic written on the fly.

**Key requirements:**
- Users/LLMs can write code that creates and updates UI components and application logic **at runtime**.
- All code runs on-device, with no backend or server-side execution.
- The parent app must be secure, performant, and app store compliant.
- The UI and logic of children apps can be reconfigured instantly by changing the code, with changes reflected in real time.

---

## 2. Proof of Concept Scope: Simple UI + Logic Rendering On The Fly

For PoC, we want to:
- Allow a user to write code (or paste code generated by an LLM) that creates a simple form (e.g., two input fields, a button, and a label).
- The code should define event handlers (e.g., clicking the button sums the two inputs and updates the label).
- When the code is changed, the UI is re-rendered and logic is re-bound instantly.
- All of this must work without a backend, using only Lynx’s runtime and APIs.

- User/LLM code creates UI components using the Element API:
  ```js
  // Example user/LLM code
  const input1 = new Element('root', 'input1', lynx);
  input1.setProperty({ type: 'number', placeholder: 'Enter number 1' });

  const input2 = new Element('root', 'input2', lynx);
  input2.setProperty({ type: 'number', placeholder: 'Enter number 2' });

  const button = new Element('root', 'sumBtn', lynx);
  button.setProperty({ type: 'button', text: 'Sum' });

  const label = new Element('root', 'resultLabel', lynx);
  label.setProperty({ text: 'Result: ' });

  button.on('click', () => {
    const sum = Number(input1.value) + Number(input2.value);
    label.setProperty({ text: `Result: ${sum}` });
  });
  ```
- Mount all elements to the preview root.

---

## 3. Lynx's Unique Advantages for Our Use Case

- **Lepus VM:** Lynx’s custom JS VM is designed for dynamic, runtime code execution. Unlike React Native (which is optimized for pre-bundled, declarative UI), Lepus allows us to evaluate and run arbitrary JS at runtime, enabling true live coding.
- **Direct UI Manipulation:** The `Element` API and modular rendering system allow JS code to create, update, and animate native UI components on the fly.
- **Sandboxing:** Lynx’s architecture makes it easier to restrict what user/LLM code can do, supporting least-privilege execution.
- **Performance:** Lynx is proven in production apps, with a modular, high-performance rendering engine.
- **Web-like API:** Familiar patterns (EventEmitter, Element, etc.) make onboarding easier for web/RN developers.

### React Native Limitations
- **Declarative, Pre-bundled Focus:** RN is optimized for declarative, pre-bundled UI trees. Dynamic code execution is possible but not idiomatic, and runtime mounting of new UI is constrained.
- **Bridge Overhead:** The JS/native bridge in RN can introduce latency and is less optimized for ad-hoc, high-frequency UI changes.
- **Sandboxing/Ecosystem:** RN exposes a broader, less-auditable API surface, and sandboxing is less tightly integrated.

---

## 4. Overview of Lynx Components

Below is a walkthrough of the most relevant Lynx components for our use case:

### Core VM & Runtime
- [`core/runtime/vm/lepus/vm_context.cc`](https://github.com/lynx-family/lynx/tree/dc59c2a8038bf5ca5657bb20f4008d3a9f5b99c0/core/runtime/vm/lepus/vm_context.cc): Implements the `VMContext` class for Lynx's Lepus VM. Responsible for executing code, managing function calls, closures, and variable context. Enables dynamic script execution at runtime.

### JS/Native Bridge
- [`core/runtime/bindings/jsi/js_app.cc`](https://github.com/lynx-family/lynx/tree/dc59c2a8038bf5ca5657bb20f4008d3a9f5b99c0/core/runtime/bindings/jsi/js_app.cc): Contains the `AppProxy` class, which bridges the Lynx runtime and JavaScript. Handles script loading, event management, state, and integration with the VM.

### Engine Proxy & Event System
- [`core/public/lynx_engine_proxy.h`](https://github.com/lynx-family/lynx/tree/dc59c2a8038bf5ca5657bb20f4008d3a9f5b99c0/core/public/lynx_engine_proxy.h): Defines the `LynxEngineProxy` interface for dispatching tasks, handling events, and managing event lifecycles between the engine and platform.

### UI Rendering & Components
- [`core/renderer/ui_component/list`](https://github.com/lynx-family/lynx/tree/dc59c2a8038bf5ca5657bb20f4008d3a9f5b99c0/core/renderer/ui_component/list): Implements adapters, containers, layout managers, and event managers for lists and grids. Supports dynamic, runtime UI updates and complex structures.

### JS API Surface
- [`js_libraries/lynx-core/src/modules/element/element.ts`](https://github.com/lynx-family/lynx/tree/dc59c2a8038bf5ca5657bb20f4008d3a9f5b99c0/js_libraries/lynx-core/src/modules/element/element.ts): User-facing JS API for interacting with native elements. The `Element` class allows creation, animation, and property updates of UI components from JS.
- [`js_libraries/lynx-core/src/index.ts`](https://github.com/lynx-family/lynx/tree/dc59c2a8038bf5ca5657bb20f4008d3a9f5b99c0/js_libraries/lynx-core/src/index.ts): Entry point for Lynx’s JS API, re-exporting all major modules and exposing the dynamic element creation API.

---

## 5. Security, Sandboxing, and App Store Considerations

- Lynx’s custom VM and proxy architecture support strong sandboxing for user/LLM code. Only whitelisted APIs are exposed to JS. No native code or privileged APIs are accessible unless explicitly allowed.
- For production, consider running untrusted code in a secondary process and providing clear user warnings.
- App Store (especially iOS) may scrutinize custom VMs. Restrict dynamic code execution to user/LLM code only, and prepare reviewer documentation explaining sandboxing and restrictions.

---

## 6. Developer Experience & Tooling

- Lynx exposes familiar, making it accessible for web developers.
- Debugging and error reporting are present, but the devtools ecosystem is less mature than RN’s. Custom log viewers or error reporting may be needed.
- Modern build system (TypeScript, ES modules) but fewer plugins/community resources than RN.

---

## 7. FAQ: RN-to-Lynx Migration

**Q: How do I create UI components at runtime in Lynx?**
A: Use the [`Element`](https://github.com/lynx-family/lynx/tree/dc59c2a8038bf5ca5657bb20f4008d3a9f5b99c0/js_libraries/lynx-core/src/modules/element/element.ts) API to instantiate and update native UI components from JS.

**Q: How is code executed at runtime?**
A: User/LLM JS is evaluated in the custom Lepus VM ([`core/runtime/vm/lepus/vm_context.cc`](https://github.com/lynx-family/lynx/tree/dc59c2a8038bf5ca5657bb20f4008d3a9f5b99c0/core/runtime/vm/lepus/vm_context.cc)), with only whitelisted APIs exposed.

**Q: What about debugging?**
A: Lynx provides error reporting and logging, but you may want to build custom log viewers for a better DX.
